\documentclass[10pt,conference,a4paper]{IEEEtran}

%import packages here
\usepackage{amsmath}
\everymath{\displaystyle}
\usepackage{graphicx}
\usepackage{caption}
\usepackage[numbers]{natbib}
\usepackage{color}
\graphicspath{{Images/}}

\title{Lucky Thirteen - A Cryptographic Analyses}
\author{Ruud Verbij \\ Student at the University of Twente \\ crypto@ruudverbij.nl}
\begin{document}
\maketitle



\begin{abstract}
\textcolor{red}{TODO: clean up the text underneath, be more elaborate, fix text from all sections.}

The attack presented by~\citeauthor{alfardan2013lucky} requires $2^{23}$ TLS connections at most to get the plaintext of one encrypted block ($16$ bytes when AES is used as a block cipher), which can be decreased with different tweaks to $2^{13}$ TLS connections per byte of a cookie.

\end{abstract}



\begin{IEEEkeywords}
Cryptography, SSL, TLS, Lucky Thirteen, Padding Oracle, Timing attacks
\end{IEEEkeywords}



\section{Introduction}
\label{sec:intro}
This paper explores the February 2013 theoretical attack on TLS (and DTLS) called \textit{Lucky Thirteen}~\cite{alfardan2013lucky}. This theoretic attack describes why the bandits used to fix TLS 1.1 and 1.2 after the attack of~\citeauthor{canvel2003password}~\cite{canvel2003password} do not provide the necessary security to the most used internet protocol.This paper is scoped to the implications of this attack on TLS Security, and does not provide information on how to apply a similar attack on DTLS. The reader is referred to~\cite{alfardan2013lucky} for details on DTLS, although mentionable is the fact that the theoretical attack on TLS, is practical for DTLS due to its nature not to terminate sessions on bad MAC or bad padding errors.

The paper is ordered as follows. First, Section~\ref{sec:crypto} will very briefly overview the cryptography (and crypto format) that's important to understand the attack. Section~\ref{sec:tls} describes the main features in TLS responsible for padding oracle attacks, which will be discussed in Section~\ref{sec:paddingoracle}. The wrongly placed bandits and their weaknesses are discussed in Section~\ref{sec:lucky} which covers the Lucky Thirteen attack. This paper will conclude with the future of TLS in Section~\ref{sec:future}.



\section{Brief overview of Cryptography}
\label{sec:crypto}
In TLS, different cryptographic primitives are used to provide confidentiality, authentication, non-repudiation and integrity while communicating over the internet. Since TLS uses a MAC-Encode-Encrypt Scheme, the different subsections of this section will describe these processes. These subsections are written with TLS in mind, and cover specifics for the implementation of TLS rather than a full description of the specific cryptographic primitive. The first subsection denotes the cryptographic format that is used in this paper.

\subsection{Cryptographic format}
\label{sec:crypto:format}
The cryptographic format used in this paper is presented in Table~\ref{sec:crypto:format:table}.
\begin{table}[h]
    \begin{tabular}{l|l}
    Format & Meaning \\ \hline
    A $||$ B    & Concatenation of A and B  \\
    A $\oplus$ B  & The bitwise XOR of A and B     \\
    H(A)    & Hash-function applied to A    \\
    $E_k$(A)    & Encryption with key K applied to A    \\
    $D_k$(A)    & Decryption with key K applied to A    \\
    \end{tabular}
    \caption{Cryptographic format used in this paper}
    \label{sec:crypto:format:table}
\end{table}

\subsection{MAC - Message Authentication Code}
\label{sec:crypto:hmac}
To ensure message integrity, RFC5246~\cite{ietf2008transport} prescribes the use of a keyed Message Authentication Code (MAC). The MAC cipher suites described in the RFC are based on hashing functions, HMACs, and are described in~\cite{krawczyk1997rfc}. Though, the RFC does not prohibit the use of other cipher suites, the implementations found by~\citeauthor{alfardan2013lucky} in~\cite{alfardan2013lucky} all restrict the use to HMAC-MD5, HMAC-SHA-1 or HMAC-SHA-256~\footnote{HMAC-MD5 has 16 bytes of MAC.\\HMAC-SHA-1 has 20 bytes of MAC.\\HMAC-SHA-256 has 32 bytes of MAC.} To compute the HMAC for a message M and key K, the specified HMAC algorithms use the following formula. 
\[ \text{HMAC}(K,M) = H((K \oplus opad)||H(K \oplus ipad)||M)). \]
With \textit{opad}, \textit{ipad} to be specific $64$-byte values and key $K$ zero-padded to $64$ bytes. "Each hash function uses a \textit{Merkle-Damg\aa rd strengthening}. Here, an 8-byte length field followed by padding of a specified byte format are appended to the message M to be hashed. The padding is at least $1$ byte in length and aligns the data on a $64$-byte boundary. The relevant hash functions also have an iterated structure, processing messages in chunks of $64$ bytes ($512$ bits) using a compression function, with the output of each compression step being chained into the next step. The compression function in turn involves a complex round structure, with many basic arithmetic operations on data being involved in each round."~\cite{alfardan2013lucky}.

\textcolor{red}{TODO: more elaborate; maybe a figure or a formula with regards to the above Merkle-Damg\aa rd strengthening.}

This means that, depending on the size of message M, the number of runs of the hash function H can be computed. Because of the Merkle-Damg\aa rd strengthening, a message M is appended by the $8$-byte length field, and padded to be a multiple of $64$ bytes. This means that the first of the Merkle-Damg\aa rd rounds consists of $55$ bytes of message M, followed by $64$ bytes for every following $64$ bytes of message M. The inner hash function depends on the $\text{message length of} M + 1$ constant hash function round, the outer hash function is a constant of $2$. This means that the following formula represents the number of hash function calls for L is the message length of M in bytes:
\[ \lceil \frac{L - 55}{64} \rceil + 4 \]

\subsection{Encoding - Padding}
\label{sec:crypto:padding}
Not specifically a cryptographic primitive, though, padding forms a core point in the different attacks explained within this paper. TLS describes the padding to be at least $1$ byte in length, with the content being the $\text{number of padding bytes} - 1$. This forces padding such as:
\["0\text{x}00", "0\text{x}01||0\text{x}01", "0\text{x}02||0\text{x}02||0\text{x}02", \text{etc.} \]

\subsection{Encryption - CBC encryption}
\label{sec:crypto:encryption}
The attack described by~\citeauthor{alfardan2013lucky}~\cite{alfardan2013lucky} makes use of one the most prominent implementations of the RFC~\cite{ietf2008transport}, namely the use of a Block Cipher in CBC-mode with a randomized IV. In practice, AES is used as the Block Cipher.

The plaintext is cut into blocks of the input size of the Block Cipher (AES has a $16$ bytes block size). Ciphertext blocks are computed as:
\[ 
\begin{split}
C_i &= E_K(P_i \oplus C_{i-1}) \\
C_0 &= \text{IV} 
\end{split}
\]
With $P_i$ the blocks of plaintext (plus extras, as described in Section~\ref{sec:tls}) and $K$ the key for Block Cipher $E$. Ciphertext $C$ is the concatenation of all $C_i$'s.



\section{TLS}
\label{sec:tls}
TLS is used to provide for a cryptographically secure connection between two entities on the internet. TLS consists of four protocols: a handshake protocol to establish a connection; an alert protocol; the change cipher spec protocol; application data protocol. In this paper, the scope will be on an already established connection between these two entities (application data protocol) rather than the other protocols because the attack by~\citeauthor{alfardan2013lucky} takes place after the handshake and without the alert of change cipher spec protocol. Furthermore, the scope is on the versions 1.1 and 1.2 of TLS. These versions have tried to fix the origin of an attack proposed by~\citeauthor{vaudenay2002security} in~\cite{vaudenay2002security}.

In the following subsections the TLS Record and the procedure of accepting a received record will be described.

\subsection{TLS Record}
\label{sec:tls:record}
The basis for the attack on TLS 1.0 has to do with the fundamental approach TLS took into the formatting their TLS Record into a MAC-Encode-Encrypt Scheme as described in Section~\ref{sec:crypto}. First the MAC is applied to the payload, preceded by a HDR~\footnote{The HDR field is a 5 byte field consisting of the version (1 byte), protocol type (2 bytes) and length of the payload.(2 bytes)} and a SQN~\footnote{The SQN field is a 8 byte field consisting of the current sequence number, which is incremented each record.} field. After which the original payload is appended by the MAC and padding, and then encrypted to become ciphertext. Figure~\ref{fig:tls} has a visual representation of an actual TLS record. Actually, this Figure contains three minor errors/simplifications: the HDR and SQN fields are switched with respect to the Figure, according to~\cite{ietf2008transport}; the padding field consists of two field, the actual padding (minimal of $1$ byte) followed by the length of this padding ($1$ byte); the ciphertext is preceded by the HDR field and the IV that is forced to be completely random and unpredictable.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.5\textwidth]{tls-representation.jpg}
	\caption{Representation of TLS record.~\cite{alfardan2013lucky}}
	\label{fig:tls}
\end{figure}

\subsection{Accepting a record}
\label{sec:tls:accepting}
The RFC~\cite{ietf2008transport} does not describe the steps that need to be taken before accepting the payload of a received TLS record, fortunately the authors of the Lucky Thirteen attack have proposed a (incomplete) list of actions to be undertaken.
\begin{itemize}
  \item Check: is the ciphertext size a multiple of the block size?
  \item Check: is the ciphertext large enough to contain at least a zero-length record, a MAC tag of the required size and at least one byte of padding?
  \item Decrypt the ciphertext to recover the plaintext blocks: $P_i = D_k(C_i) \oplus C_{i-1}$.
  \item Is the padding of the appropriate format?
  \item Is the MAC correct (using the correct SEQ number and HDR field?
\end{itemize}
Since the attack by~\citeauthor{vaudenay2002security}~\cite{vaudenay2002security} on TLS 1.0, exploiting timing differences when accepting records, it is advised by TLS 1.2~\cite{ietf2008transport} to avoid timing differences by assuming zero-length padding if the padding format sanity check does not work out. In this case, the MAC is still calculated, but the record is nonetheless discarded. More on this in Section~\ref{sec:paddingoracle}.



\section{Padding Oracle}
\label{sec:paddingoracle}
Padding Oracle attacks form the building block for the Lucky Thirteen attack, which is the main topic of this paper and will be discussed in Section~\ref{sec:lucky}. Padding oracles are protocols, servers or web applications (named oracles) that reveal information on the correctness of the used padding, as described in Section~\ref{sec:crypto:padding}. By leaking information on the correctness of the padding, these oracles leak vital information on the plaintext. This Section will first address the use of padding oracles in the attack proposed by~\citeauthor{vaudenay2002security}~\cite{vaudenay2002security} on TLS 1.0~\cite{dierks1999rfc} after which some information on \textit{Bomb oracles} will elaborated upon.

\subsection{~\citeauthor{vaudenay2002security} attack on TLS 1.0}
\label{sec:paddingoracle:padding}
For this Section, w.l.o.g., it will be assumed that this application data protocol run uses the HMAC\_SHA1 with AES\_CBC mode~\footnote{This makes for t = 20 bytes MAC size. \\ b = 16 bytes block size}. The format in this Section mostly depends upon the same format as used in~\cite{alfardan2013lucky}, to keep consistency throughout the literature. Furthermore, this subsection is heavily inspired by ~\cite{alfardan2013lucky,vaudenay2002security}.

Recall the following two formulas to calculate ciphertexts (when  encrypting) and plaintexts (when decrypting).
\[
\begin{split}
C_i &= E_K(P_i \oplus C_{i-1}) \\
P_i &= D_K(C_i) \oplus C_{i-1} \\
C_0 &= \text{IV} \\
&= P_0
\end{split}
\]
By pushing different ciphertexts towards the Oracle, the attacker can control the bytes that are checked by the Oracle. When the Oracle receives the encrypted record, it will first check if the ciphertext is of a correct size, after which it will start to decrypt. After decryption, the Oracle needs to check the validity of the padding and then remove it from the record. In the old TLS version 1.0~\cite{dierks1999rfc}, whenever the padding was incorrect, an error-message was sent to the sender of the record (the attacker). This means that the attacker can query for valid padding of the plaintext of which he sent and encrypted version off. Recall the strict way padding is allowed in TLS as described in Section~\ref{sec:crypto:padding}. Knowing if the plaintext version of an encrypted record includes a valid padding thus leaks information on the plaintext.

Now lets consider, one wants to have the plaintext block $P^{*}$ corresponding to the ciphertext block $C^{*}$ gotten from somewhere in a ciphertext stream, assuming ciphertext block $C^{'}$ precedes this ciphertext $C^{*}$. This means that the plaintext block $P^{*}$ could be calculated in the following way.
\[ P^{*} = D_K(C^{*}) \oplus C^{'} \]
Lets form a ciphertext function $C^{att}$ that depends on some $\Delta$, which also contain the interesting ciphertext blocks $C^{'}$ and then one of which the plaintext is needed $C^{*}$. All $C$'s are blocks of the correct block size.
\[ \begin{split}
C^{att}(\Delta) &= \text{HDR} || C_0 || C_1 || C_2 || C^{'} \oplus \Delta || C^{*} \\
\text{With } C_0 &= \text{IV}, \\
C_3 &= C^{'} \oplus \Delta \\
\text{And } C_4 &= C^{*}
\end{split}  \]
Of interest now, is $C_4$ ($C^{*}$), which corresponds to $P_4$ ($P^{*}$), but has slightly changed due to the transformation with $\Delta$.
\[ \begin{split}
P_4 &= D_K(C^{*}) \oplus (C^{'} \oplus \Delta) \\
&= P^{*} \oplus \Delta \\
\end{split} \]

If this $C^{att}$ is sent towards an Oracle, one of three things can happen internally in the Oracle, of which we can separate two categories.
\begin{enumerate}
  \item The padding gets accepted. This happens in two cases.
	\begin{itemize}
		\item The last byte of $P_4$ ends with a $0\text{x}00$ byte. This is seen as valid padding, and chopped off. The last $20$ bytes of $P_4$ that are left are seen as MAC, with the plaintext record that's left with length $64 - 21 (\text{padding and MAC}) = 43 \text{bytes}$. The MAC of $20$ bytes is calculated on $\text{SQN} || \text{HDR} || 43 \text{ bytes plaintext R} = 56\text{ bytes}$.
		\item The decrypted $C^{att}$ contains a different byte pattern of which the last $X$ are seen as a valid padding. This could be one as mentioned in Section~\ref{sec:crypto:padding}, of which every 'higher' version of padding is less likely by a factor of $2^8$ (byte). This means that there are at least $2$ bytes of padding chopped off at the end, after which a $20$ bytes MAC is also chopped off, with a remainder of at most $64 - 22 (\text{padding and MAC}) = 42 \text{bytes}$. The MAC of $20$ bytes is calculated on $\text{SQN} || \text{HDR} || 42 \text{ bytes plaintext R at most} = 55\text{ bytes}$.
	\end{itemize}
  \item The padding does not get accepted. This means that the last bytes of the decrypted version of $C^{att}$ do not contain a pattern as described in category 1. As specified in TLS 1.0~\cite{dierks1999rfc},a \texttt{decryption\_failed} error is thrown. For the sake of Section~\ref{sec:lucky}, we also describe the implementation of TLS 1.1 and 1.2~\cite{ietf2008transport}. In this specification, the padding should be considered of zero length, resulting in the last $20$ bytes of the decrypted $C^{att}$ to be considered the MAC which is calculated on $\text{SQN} || \text{HDR} || 44 (64 - 20) \text{ bytes plaintext R} = 57\text{ bytes}$.
\end{enumerate}

\subsection{Bomb Oracles}
\label{sec:paddingoracle:bomb}
Problem: \texttt{decryption\_failed} is a fatal error. \\
\textcolor{red}{TODO: fixed using D, with multi-session TLS attacks}



\section{Lucky Thirteen}
\label{sec:lucky}
The RFC of TLS 1.2~\cite{ietf2008transport} reports
\begin{quote}
Implementation note: Canvel et al. [CBCTIME] have demonstrated a timing attack on CBC padding based on the time required to compute the MAC.  In order to defend against this attack, implementations MUST ensure that record processing time is essentially the same whether or not the padding is correct.  In general, the best way to do this is to compute the MAC even if the padding is incorrect, and only then reject the packet.  For instance, if the pad appears to be incorrect, the implementation might assume a zero-length pad and then compute the MAC.  This leaves a small timing channel, since MAC performance depends to some extent on the size of the data fragment, but it is not believed to be large enough to be exploitable, due to the large block size of existing MACs and the small size of the timing signal.
\end{quote}

regular plaintext recovery of a block: 2\^23 connections
if base64 (cookies, http basic access authentication) used: 2\^23 -> 2\^19 connection per block
per cookie byte, using BEAST technique: 2\^13 connections



\section{The Future of TLS}
\label{sec:future}



\bibliographystyle{plainnat}
%\bibliographystyle{IEEEtran}
\bibliography{IEEEabrv,literature}
\end{document}






























